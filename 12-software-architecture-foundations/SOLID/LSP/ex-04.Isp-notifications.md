# Learning Exercise: Interface Segregation Principle (ISP)

## Goal

Understand why forcing classes to implement methods they don’t need leads to:

- fragile code
- runtime errors
- hidden LSP violations

This exercise continues directly from the **PaymentMethod / RefundablePaymentMethod** lesson.

---

## Problem Context

We are building a **notification system**.

Different notification types have different capabilities:

- some can be sent
- some can be scheduled
- some can be cancelled

❗ Not all notification types support all operations.

---

## Step 1: Initial (Bad) Design

```js
class Notification {
  send() {
    throw new Error("Not implemented");
  }

  schedule(date) {
    throw new Error("Not implemented");
  }

  cancel() {
    throw new Error("Not implemented");
  }
}
class EmailNotification extends Notification {
  send() {
    console.log("Email sent");
  }

  schedule(date) {
    console.log("Email scheduled for", date);
  }

  cancel() {
    console.log("Email cancelled");
  }
}

class SMSNotification extends Notification {
  send() {
    console.log("SMS sent");
  }

  schedule(date) {
    // ❌ SMS cannot be scheduled
    throw new Error("SMS cannot be scheduled");
  }

  cancel() {
    // ❌ SMS cannot be cancelled
    throw new Error("SMS cannot be cancelled");
  }
}
```
